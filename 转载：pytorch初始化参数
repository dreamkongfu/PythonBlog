æ¨¡å‹çš„å‚æ•°åˆå§‹åŒ–
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

æœ¬æ–‡ç›®å½•

1. xavieråˆå§‹åŒ–
2. kaimingåˆå§‹åŒ–
3. å®é™…ä½¿ç”¨ä¸­çœ‹åˆ°çš„åˆå§‹åŒ–
3.1 ResNeXtï¼Œdensenetä¸­åˆå§‹åŒ–
3.2 wide-residual-networksä¸­åˆå§‹åŒ–ï¼ˆMSRinitï¼‰
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

è½¬è½½è¯·æ³¨æ˜å‡ºå¤„ï¼š

http://www.cnblogs.com/darkknightzh/p/8297793.html

å‚è€ƒç½‘å€ï¼š

http://pytorch.org/docs/0.3.0/nn.html?highlight=kaiming#torch.nn.init.kaiming_normal

https://github.com/prlz77/ResNeXt.pytorch/blob/master/models/model.py

https://github.com/facebookresearch/ResNeXt/blob/master/models/resnext.lua

https://github.com/bamos/densenet.pytorch/blob/master/densenet.py

https://github.com/szagoruyko/wide-residual-networks/blob/master/models/utils.lua

è¯´æ˜ï¼šæš‚æ—¶å°±è¿™ä¹ˆå¤šå§ï¼Œé”™è¯¯ä¹‹å¤„è¯·è§è°…ã€‚å‰ä¸¤ä¸ªåˆå§‹åŒ–çš„æ–¹æ³•è§pytorchå®˜æ–¹æ–‡æ¡£

å›åˆ°é¡¶éƒ¨(go to top)
1. xavieråˆå§‹åŒ–
torch.nn.init.xavier_uniform(tensor, gain=1)

å¯¹äºè¾“å…¥çš„tensoræˆ–è€…å˜é‡ï¼Œé€šè¿‡è®ºæ–‡Understanding the difficulty of training deep feedforward neural networksâ€ - Glorot, X. & Bengio, Y. (2010)çš„æ–¹æ³•åˆå§‹åŒ–æ•°æ®ã€‚åˆå§‹åŒ–æœä»å‡åŒ€åˆ†å¸ƒğ‘ˆ(âˆ’ğ‘,ğ‘)ï¼Œå…¶ä¸­ğ‘=ğ‘”ğ‘ğ‘–ğ‘›Ã—2/(ğ‘“ğ‘ğ‘›_ğ‘–ğ‘›+ğ‘“ğ‘ğ‘›_ğ‘œğ‘¢ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšÃ—3â€¾âˆšï¼Œè¯¥åˆå§‹åŒ–æ–¹æ³•ä¹Ÿç§°Glorot initialisationã€‚

å‚æ•°ï¼š

      tensorï¼šnç»´çš„ torch.Tensor æˆ–è€… autograd.Variableç±»å‹çš„æ•°æ®

      aï¼šå¯é€‰æ‹©çš„ç¼©æ”¾å‚æ•°

ä¾‹å¦‚ï¼š

w = torch.Tensor(3, 5)
nn.init.xavier_uniform(w, gain=nn.init.calculate_gain('relu'))
torch.nn.init.xavier_normal(tensor, gain=1)

å¯¹äºè¾“å…¥çš„tensoræˆ–è€…å˜é‡ï¼Œé€šè¿‡è®ºæ–‡Understanding the difficulty of training deep feedforward neural networksâ€ - Glorot, X. & Bengio, Y. (2010)çš„æ–¹æ³•åˆå§‹åŒ–æ•°æ®ã€‚åˆå§‹åŒ–æœä»é«˜æ–¯åˆ†å¸ƒğ‘(0,ğ‘ ğ‘¡ğ‘‘)ï¼Œå…¶ä¸­ğ‘ ğ‘¡ğ‘‘=ğ‘”ğ‘ğ‘–ğ‘›Ã—2/(ğ‘“ğ‘ğ‘›_ğ‘–ğ‘›+ğ‘“ğ‘ğ‘›_ğ‘œğ‘¢ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšï¼Œè¯¥åˆå§‹åŒ–æ–¹æ³•ä¹Ÿç§°Glorot initialisationã€‚

å‚æ•°ï¼š

      tensorï¼šnç»´çš„ torch.Tensor æˆ–è€… autograd.Variableç±»å‹çš„æ•°æ®

      aï¼šå¯é€‰æ‹©çš„ç¼©æ”¾å‚æ•°

ä¾‹å¦‚ï¼š

w = torch.Tensor(3, 5)
nn.init.xavier_normal(w)
å›åˆ°é¡¶éƒ¨(go to top)
2. kaimingåˆå§‹åŒ–
torch.nn.init.kaiming_uniform(tensor, a=0, mode='fan_in')

å¯¹äºè¾“å…¥çš„tensoræˆ–è€…å˜é‡ï¼Œé€šè¿‡è®ºæ–‡â€œDelving deep into rectifiers: Surpassing human-level performance on ImageNet classificationâ€ - He, K. et al. (2015)çš„æ–¹æ³•åˆå§‹åŒ–æ•°æ®ã€‚åˆå§‹åŒ–æœä»å‡åŒ€åˆ†å¸ƒğ‘ˆ(âˆ’ğ‘ğ‘œğ‘¢ğ‘›ğ‘‘,ğ‘ğ‘œğ‘¢ğ‘›ğ‘‘)ï¼Œå…¶ä¸­ğ‘ğ‘œğ‘¢ğ‘›ğ‘‘=2/((1+ğ‘2)Ã—ğ‘“ğ‘ğ‘›_ğ‘–ğ‘›)â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšÃ—3â€¾âˆšï¼Œè¯¥åˆå§‹åŒ–æ–¹æ³•ä¹Ÿç§°He initialisationã€‚

å‚æ•°ï¼š

      tensorï¼šnç»´çš„ torch.Tensor æˆ–è€… autograd.Variableç±»å‹çš„æ•°æ®

      aï¼šè¯¥å±‚åé¢ä¸€å±‚çš„æ¿€æ´»å‡½æ•°ä¸­è´Ÿçš„æ–œç‡(é»˜è®¤ä¸ºReLUï¼Œæ­¤æ—¶a=0)

      modeï¼šâ€˜fan_inâ€™ (default) æˆ–è€… â€˜fan_outâ€™. ä½¿ç”¨fan_inä¿æŒweightsçš„æ–¹å·®åœ¨å‰å‘ä¼ æ’­ä¸­ä¸å˜ï¼›ä½¿ç”¨fan_outä¿æŒweightsçš„æ–¹å·®åœ¨åå‘ä¼ æ’­ä¸­ä¸å˜ã€‚

ä¾‹å¦‚ï¼š

w = torch.Tensor(3, 5)
nn.init.kaiming_uniform(w, mode='fan_in')
torch.nn.init.kaiming_normal(tensor, a=0, mode='fan_in')

å¯¹äºè¾“å…¥çš„tensoræˆ–è€…å˜é‡ï¼Œé€šè¿‡è®ºæ–‡â€œDelving deep into rectifiers: Surpassing human-level performance on ImageNet classificationâ€ - He, K. et al. (2015)çš„æ–¹æ³•åˆå§‹åŒ–æ•°æ®ã€‚åˆå§‹åŒ–æœä»é«˜æ–¯åˆ†å¸ƒğ‘(0,ğ‘ ğ‘¡ğ‘‘)ï¼Œå…¶ä¸­ğ‘ ğ‘¡ğ‘‘=2/((1+ğ‘2)Ã—ğ‘“ğ‘ğ‘›_ğ‘–ğ‘›)â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšï¼Œè¯¥åˆå§‹åŒ–æ–¹æ³•ä¹Ÿç§°He initialisationã€‚

å‚æ•°ï¼š

      tensorï¼šnç»´çš„ torch.Tensor æˆ–è€… autograd.Variableç±»å‹çš„æ•°æ®

      aï¼šè¯¥å±‚åé¢ä¸€å±‚çš„æ¿€æ´»å‡½æ•°ä¸­è´Ÿçš„æ–œç‡(é»˜è®¤ä¸ºReLUï¼Œæ­¤æ—¶a=0)

      modeï¼šâ€˜fan_inâ€™ (default) æˆ–è€… â€˜fan_outâ€™. ä½¿ç”¨fan_inä¿æŒweightsçš„æ–¹å·®åœ¨å‰å‘ä¼ æ’­ä¸­ä¸å˜ï¼›ä½¿ç”¨fan_outä¿æŒweightsçš„æ–¹å·®åœ¨åå‘ä¼ æ’­ä¸­ä¸å˜ã€‚

ä¾‹å¦‚ï¼š

w = torch.Tensor(3, 5)
nn.init.kaiming_normal(w, mode='fan_out')
ä½¿ç”¨çš„ä¾‹å­ï¼ˆå…·ä½“å‚è§åŸå§‹ç½‘å€ï¼‰ï¼š

https://github.com/prlz77/ResNeXt.pytorch/blob/master/models/model.py

å¤åˆ¶ä»£ç 
from torch.nn import init
self.classifier = nn.Linear(self.stages[3], nlabels)
init.kaiming_normal(self.classifier.weight)
for key in self.state_dict():
    if key.split('.')[-1] == 'weight':
        if 'conv' in key:
            init.kaiming_normal(self.state_dict()[key], mode='fan_out')
        if 'bn' in key:
            self.state_dict()[key][...] = 1
    elif key.split('.')[-1] == 'bias':
        self.state_dict()[key][...] = 0
å¤åˆ¶ä»£ç 
å›åˆ°é¡¶éƒ¨(go to top)
3. å®é™…ä½¿ç”¨ä¸­çœ‹åˆ°çš„åˆå§‹åŒ–
3.1 ResNeXtï¼Œdensenetä¸­åˆå§‹åŒ–
https://github.com/facebookresearch/ResNeXt/blob/master/models/resnext.lua

https://github.com/bamos/densenet.pytorch/blob/master/densenet.py

conv

n = kW* kH*nOutputPlane
weight:normal(0,math.sqrt(2/n))
bias:zero()
batchnorm

weight:fill(1)
bias:zero()
linear

bias:zero()
3.2 wide-residual-networksä¸­åˆå§‹åŒ–ï¼ˆMSRinitï¼‰
https://github.com/szagoruyko/wide-residual-networks/blob/master/models/utils.lua

conv

n = kW* kH*nInputPlane
weight:normal(0,math.sqrt(2/n))
bias:zero()
linear

bias:zero()
